{Application 'TANAYBASICDATA' logic file generated by CSPro}
PROC GLOBAL


array string labels(99);
array codes(99);

function string SexPronoun()
	if BI_SEX = 1 then 	SexPronoun = "his";
	else				SexPronoun = "her";
	endif;
end;


PROC INHABITANT_FF

PROC BI_PROVINCE
onfocus

// Build dynamic value set for selected REGION based on PROVINCE in lookup file
numeric nextEntry = 0;

// Start with the first PROVINCE in the REGION (PROVINCE 1)
GEO_REGION = BI_REGION;
GEO_PROVINCE = 1;
GEO_MUNICIPAL = notappl;
GEO_BARANGAY = notappl;
GEO_CLASS = notappl;
GEO_EA = notappl;

// Loop through all PROVINCE in selected REGION starting with PROVINCE 1
// The call to locate finds the next case whose ids match or are greater than the desired PROVINCE. If the PROVINCES are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS,GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION then
		// The next case is in a different REGION so there are no more PROVINCE in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a PROVINCE meaning that
	// the PROVINCE is not blank, the MUNICIPAL, BARANGAY and EA are blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL = notappl and GEO_BARANGAY = notappl and GEO_CLASS = notappl and GEO_EA = notappl then
		// Add the PROVINCE to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_PROVINCE;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next PROVINCE
	GEO_PROVINCE = GEO_PROVINCE + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_PROVINCE, codes, labels);

PROC BI_MUNICIPAL
onfocus

// Build dynamic value set for selected REGION and PROVINCE based on MUNICIPALS in lookup file
numeric nextEntry = 0;

// Start with the first MUNICIPAL in the PROVINCE in the REGION (MUNICIPAL 1)
GEO_REGION = BI_REGION;
GEO_PROVINCE = BI_PROVINCE;
GEO_MUNICIPAL = 1;
GEO_BARANGAY = notappl;
GEO_CLASS = notappl;
GEO_EA = notappl;

// Loop through all MUNICIPALS in selected PROVINCE in the selected REGION starting with MUNICIPAL 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS,GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION or GEO_PROVINCE <> BI_PROVINCE then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY = notappl and GEO_CLASS = notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_MUNICIPAL;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d class=%d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_MUNICIPAL = GEO_MUNICIPAL + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_MUNICIPAL, codes, labels);

PROC BI_BARANGAY
onfocus

// Build dynamic value set for selected REGION and PROVINCE and MUNICIPAL based on BARANGAYS in lookup file
numeric nextEntry = 0;

// Start with the first BARANGAY in the MUNICIPAL in the PROVINCE in the REGION (BARANGAY 1)
GEO_REGION = BI_REGION;
GEO_PROVINCE = BI_PROVINCE;
GEO_MUNICIPAL = BI_MUNICIPAL;
GEO_BARANGAY = 1;
GEO_CLASS = notappl;
GEO_EA = notappl;

// Loop through all BARANGAYS in selected MUNICIPAL in the PROVINCE in the selected REGION starting with BARANGAY 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION or GEO_PROVINCE <> BI_PROVINCE or GEO_MUNICIPAL <> BI_MUNICIPAL then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY <> notappl and GEO_CLASS = notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_BARANGAY;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_BARANGAY = GEO_BARANGAY + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_BARANGAY, codes, labels);



PROC BI_CLASS
onfocus

// Build dynamic value set for selected REGION and PROVINCE and MUNICIPAL based on BARANGAYS in lookup file
numeric nextEntry = 0;

// Start with the first BARANGAY in the MUNICIPAL in the PROVINCE in the REGION (BARANGAY 1)
GEO_REGION = BI_REGION;
GEO_PROVINCE = BI_PROVINCE;
GEO_MUNICIPAL = BI_MUNICIPAL;
GEO_BARANGAY = BI_CLASS;
GEO_CLASS = 1;
GEO_EA = notappl;

// Loop through all BARANGAYS in selected MUNICIPAL in the PROVINCE in the selected REGION starting with BARANGAY 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION or GEO_PROVINCE <> BI_PROVINCE or GEO_MUNICIPAL <> BI_MUNICIPAL or GEO_BARANGAY <> BI_BARANGAY then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY <> notappl and GEO_CLASS <> notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_CLASS;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_CLASS = GEO_CLASS + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_CLASS, codes, labels);




PROC BI_EA
onfocus

// Build dynamic value set for selected REGION and PROVINCE and MUNICIPAL based on BARANGAYS in lookup file
numeric nextEntry = 0;

// Start with the first BARANGAY in the MUNICIPAL in the PROVINCE in the REGION (BARANGAY 1)
GEO_REGION = BI_REGION;
GEO_PROVINCE = BI_PROVINCE;
GEO_MUNICIPAL = BI_MUNICIPAL;
GEO_BARANGAY = BI_BARANGAY;
GEO_CLASS = BI_CLASS;
GEO_EA = 1;

// Loop through all BARANGAYS in selected MUNICIPAL in the PROVINCE in the selected REGION starting with BARANGAY 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_CLASS, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION or GEO_PROVINCE <> BI_PROVINCE or GEO_MUNICIPAL <> BI_MUNICIPAL or GEO_BARANGAY <> BI_BARANGAY or GEO_CLASS <> BI_CLASS then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY <> notappl and GEO_EA <> notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_EA;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_EA = GEO_EA + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_EA, codes, labels);

PROC PERSONAL_INFO_FORM
// After adults roster is complete, check to make sure that there is 
// exactly one head of household. 
numeric numberOfHeads = 0; 
do numeric i = 1 while i <= totocc(PERSONAL_INFO_FORM)
    if BI_RELATIONSHIP(i) = 1 then
            numberOfHeads = numberOfHeads + 1;
    endif;
    enddo; 
    if numberOfHeads <> 1 then
        errmsg("Number of heads of household must be exactly one");
            reenter BI_RELATIONSHIP(1); 
            endif;

PROC BI_FNAME
if curocc() = 1 then    
	// Set label for case in case listing to an easier to read format.
    // We do this when we first get the name of the head.    
    string caseLabel = maketext("%02d-%02d-%02d-%03d-%03d-%03d-%04d: %s",        
    	BI_REGION, BI_PROVINCE, BI_MUNICIPAL, BI_BARANGAY, BI_EA,BI_SEGMENT,        
    	BI_HH_NUMBER, strip(BI_NAME));    
    setcaselabel(INHABITANT_DICT, caseLabel); 
endif;

PROC BI_COUNTRY

onfocus

// Build dynamic value set for selected REGION based on PROVINCE in lookup file
numeric nextEntry = 0;

// Start with the first PROVINCE in the REGION (PROVINCE 1)
COUNTRY_CONTINENT = BI_CONTINENT;
COUNTRY_COUNTRY = 1;

// Loop through all PROVINCE in selected REGION starting with PROVINCE 1
// The call to locate finds the next case whose ids match or are greater than the desired PROVINCE. If the PROVINCES are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(COUNTRY_DICT, >=, maketext("%d%03d", COUNTRY_CONTINENT, COUNTRY_COUNTRY)) and loadcase(COUNTRY_DICT) do

	if COUNTRY_CONTINENT <> BI_CONTINENT then
		// The next case is in a different REGION so there are no more PROVINCE in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a PROVINCE meaning that
	// the PROVINCE is not blank, the MUNICIPAL, BARANGAY and EA are blank.
	if COUNTRY_COUNTRY <> notappl then
		// Add the PROVINCE to the value set
		labels(nextEntry) = COUNTRY_NAME;
		codes(nextEntry) = COUNTRY_COUNTRY;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next PROVINCE
	COUNTRY_COUNTRY = COUNTRY_COUNTRY + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_COUNTRY, codes, labels);

PROC BI_REGION_BIRTH
preproc

 if BI_COUNTRY <> 608 then
 	skip to BI_sex;
endif;

PROC BI_PROVINCE_BIRTH
onfocus

// Build dynamic value set for selected REGION based on PROVINCE in lookup file
numeric nextEntry = 0;

// Start with the first PROVINCE in the REGION (PROVINCE 1)
GEO_REGION = BI_REGION_BIRTH;
GEO_PROVINCE = 1;
GEO_MUNICIPAL = notappl;
GEO_BARANGAY = notappl;
GEO_EA = notappl;

// Loop through all PROVINCE in selected REGION starting with PROVINCE 1
// The call to locate finds the next case whose ids match or are greater than the desired PROVINCE. If the PROVINCES are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION_BIRTH then
		// The next case is in a different REGION so there are no more PROVINCE in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a PROVINCE meaning that
	// the PROVINCE is not blank, the MUNICIPAL, BARANGAY and EA are blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL = notappl and GEO_BARANGAY = notappl and GEO_EA = notappl then
		// Add the PROVINCE to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_PROVINCE;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next PROVINCE
	GEO_PROVINCE = GEO_PROVINCE + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_PROVINCE_BIRTH, codes, labels);

PROC BI_MUNICIPAL_BIRTH
onfocus

// Build dynamic value set for selected REGION and PROVINCE based on MUNICIPALS in lookup file
numeric nextEntry = 0;

// Start with the first MUNICIPAL in the PROVINCE in the REGION (MUNICIPAL 1)
GEO_REGION = BI_REGION_BIRTH;
GEO_PROVINCE = BI_PROVINCE_BIRTH;
GEO_MUNICIPAL = 1;
GEO_BARANGAY = notappl;
GEO_EA = notappl;

// Loop through all MUNICIPALS in selected PROVINCE in the selected REGION starting with MUNICIPAL 1
// The call to locate finds the next case whose ids match or are greater than the desired MUNICIPAL. If the districts are
// numbered sequentially with no gaps then this will be an exact match but if there are gaps then it will skip
// over them.
while locate(GEOCODE_DICT, >=, maketext("%02d%02d%02d%03d%03d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA)) and loadcase(GEOCODE_DICT) do

	if GEO_REGION <> BI_REGION_BIRTH or GEO_PROVINCE <> BI_PROVINCE_BIRTH then
		// The next case is in a different REGION or in a different PROVINCE so there are no more MUNICIPALS in this PROVINCE or in this REGION
		// and we are done.
		break;
	endif;
	
	// If the structure of the lookup file is correct, we should be on a case for a MUNICIPAL meaning that
	// the REGION and PROVINCE are not blank and the village is blank.
	if GEO_PROVINCE <> notappl and GEO_MUNICIPAL <> notappl and GEO_BARANGAY = notappl and GEO_EA = notappl then
		// Add the district to the value set
		labels(nextEntry) = GEO_AREA_NAME;
		codes(nextEntry) = GEO_MUNICIPAL;
		nextEntry = nextEntry + 1;
	else
		errmsg("Geo code lookup has invalid structure on line: reg=%02d prov=%02d mun=%02d bgy=%03d ea=%3d", GEO_REGION, GEO_PROVINCE, GEO_MUNICIPAL, GEO_BARANGAY, GEO_EA);
		exit;
	endif;
	
	// Find the next district
	GEO_MUNICIPAL = GEO_MUNICIPAL + 1;
enddo;

// Add terminator to value set
codes(nextEntry) = notappl;

setvalueset(BI_MUNICIPAL_BIRTH, codes, labels);


PROC BI_RELATIONSHIP
	
onfocus 
	// Show male or female version of value set depending on sex of the person. 
	if BI_SEX = 1 then
    	setvalueset(BI_RELATIONSHIP, BI_RELATIONSHIP_MALE);
	else
    	setvalueset(BI_RELATIONSHIP, BI_RELATIONSHIP_FEMALE); 
	endif;
 
postproc
 
 	if BI_CIVIL_STATUS = 2 and $ = 2 then
		errmsg ("%s has relationship spouse and marital status %s.  Spouse cannot be single, widowed, separated",
		strip(BI_NAME(curocc())), getlabel(BI_CIVIL_STATUS))
			select ("Please choose the right Civil Status",BI_CIVIL_STATUS,
			"Please choose the right Relationship to Household Head", BI_RELATIONSHIP);
	endif;
PROC ADD_HOUSEHOLD_MEMBER
// Exit roster when no more people in household 
	if $ = 2 then
	    endgroup; 
	endif; 
